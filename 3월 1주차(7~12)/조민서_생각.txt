-- 깊이우선 탐색 1

N개의 정점과 M개의 간선과 시작점 R을 입력,
Int visitOrder [N+1]을 만들어서 방문 순서 기록 
ArrayList<Integer> N+1개를 만든 후, 입력받은 정점끼리 연결 후 시작점을 기준으로 DFS 
방문 유무는 boolean visited[]으로 구별

-- 토마토

 토마토가 잘 익은 경우 Queue에 추가 큐는 x,y,z,좌표와 0(day 날짜)을 넣음
bfs로 visited 3차원 활용, dx,dy,dz (z는 -1,1) 
for문으로 상하 좌우 안익은 토마토인 경우 큐에 추가 & Max 값 현재 day +1로 갱신 
For 문으로 윗칸 아랫칸 안익은 토마토인 경우 큐에 추가 & Max 값 현재 day +1로 갱신,

count라는 변수를 하나 두어서 익을 수 있는 지 유무 판단


--나이트의 이동

한변 길이 N 와, 시작 점과 끝점을 입력
같으면 0을 반환 아니면
Boolean check [][] N 만큼 초기화 시켜주기
Int cnt [][] 301 (체스 칸 만큼) 
bfs진행  시작점 cat =1 로 초기화 &큐에 시작점 넣기 &dx,dy 사용하여 진행. 도착점 일시 cnt[도착점] 출력하고 return


-- 유사칸토어 비트열

1은 항상 11011로 바뀌고 0은 항상 00000로 변환된다.
N
1 : 1 :1 
2 : 11011 :4
3 : 1101111011000001101111011 :16 ... 그전 1의 갯수 *4 만큼 증식
이런식으로 증식 
L ~r까지의 1의 갯수를 구해야함.. -> l,r이 5의 몇 제곱인지 구하기.. 이걸로 판단해서 진행..?


-- 상어초등학교

입력을 받을때 좋아하는 친구들을 기록해두고 이중 for문을 통해서 주변에 좋아하는 학생이 있는지, 없으면 빈공간이 많은 경우 기록하기..
마지막에 사방 탐색을 진행하며 주변에 좋아하는 학생이 있는지 확인해서 더해준다.